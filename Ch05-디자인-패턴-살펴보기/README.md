## 디자인 패턴과 가독성
### 디자인 패턴
- 특정상황에 반복적으로 나타나는 문제들에 대한 해결법, 모범사례
### 왜 디자인 패턴을 설명?
- 디자인 패턴 암기 X
- 모범사례(Best Practice)를 통해 시야확장
- 유연한 설계를 지닌 객체지향의 장점을 살펴보는것
- 디자인 패턴의 이름으로 명명된 클래스들이 다수 존재
### SOLID 원칙
- SRP Single Responsibility Principle 단일 책임 원칙
- OCP Open/Closed Principle 개방-폐쇄 원칙
- LSP Liskov Subsitution Principle 리스코프 치환 원칙
- ISP Interface Segregation Principle 인터페이스 분리 원칙
- DIP Dependency Inversion Principle 의존관계 역전 원칙
## Singleton
### 해결하려는 문제
- 클래스의 인스턴스가 단 1개임을 보장해야함
- 인스턴스 생성을 제어할 수 있어야함
- 1개뿐인 인스턴스에 쉽게 접근할 수 있어야함 (글로벌)
## Builder
### 해결하려는 문제
- 복잡한 객체의 생성방법과 표현방법을 분리해야함
- 생성방법과 구성방법 모두 캡슐화 해야함 ex) 객체 생성에 필요한 파라미터가 너무많음 / 생성자 오버로딩이 과함
## Factory Method
### 해결하려는 문제
- 복잡한 객체 생성을 캡슐화 해야함
- 생성은 다른 클래스(Factory) 에게 위임하려함
- 어떤 인스턴스를 만들어야 할지 알 수 없음
## Adaptor
### 해결하려는 문제
- 인터페이스가 맞지 않을때 (플러그)
- 서로 다른 인터페이스를 함께 동작하고자 함
## Facade
### 해결하려는 문제
- 복잡한 서브시슽템에 인터페이스를 단순하게 구성하고자 할때
- 시스템간에 결합도를 줄이고자 할때
- 서브 시스템을 계층화 시키고 싶을때
## Decorator
### 해결하려는 문제
- 기존 객체 수정없이 새로운 책임을 추가하고 싶을 때
## Proxy
### 해결하려는 문제
- 객체에 접근을 제어하고 싶을때
-> 객체를 실제 사용하기 전까지 초기화를 미루고 싶을때 (Lazy init)
-> 접근 권한 체크
## Strategy
### 해결하려는 문제
- 클라이언트에 독립적으로 문제 해결 전략을 바꾸고 싶을때
- 다양한 문제 해결 방법을 제공해야할때
## Template Method
### 해결하려는 문제
- 문제해결의 큰 흐름은 유지하고, 단계별 처리는 위임하고자 할때
- 구체적인 처리방법은 하위 클래스로 위임하고자 할때
## Chin of responsibility
### 해결하려는 문제
- 메세지를 보내는 객체와 처리하는 객체를 분리하고 싶을때
- 하나의 메시지를 여러 객체가 처리해야할 때






















